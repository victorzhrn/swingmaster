# Skeleton Visualization Implementation Plan

## Feature Context
**Goal**: Add real-time skeleton overlay option to show body pose on both user and pro videos during playback.

**Current State**: 
- TrajectorySelector shows motion paths (racket/wrist trajectories)
- SkeletonOverlay component exists and can render pose data
- Shot objects contain paddedPoseFrames with pose data at each timestamp

**Desired Behavior**:
- New "Skeleton" option in trajectory selector
- When selected, shows live pose skeleton that updates during playback
- In compare mode, both videos show synchronized skeletons

---

## Implementation Plan

### 1. Extend TrajectorySelector Options

```
TrajectoryOption enum:
  - Add case: skeleton = "Skeleton"
  - For skeleton case: trajectoryType returns nil
  
Add new binding:
  @Binding showSkeleton: Bool
  
Selection logic:
  IF skeleton selected:
    - Clear enabledTrajectories
    - Set showSkeleton = true
  ELSE:
    - Set showSkeleton = false
    - Update enabledTrajectories as normal
```

### 2. Add Skeleton State to AnalysisView

```
State variables:
  @State showSkeleton = false
  @State currentUserPose: PoseFrame? = nil
  @State currentProPose: PoseFrame? = nil

Pass to TrajectorySelector:
  showSkeleton: $showSkeleton
```

### 3. Create Frame Extraction Logic

```
FUNCTION getCurrentPoseFrame(frames: [PoseFrame], atTime: Double) -> PoseFrame?
  IF frames.isEmpty: return nil
  
  // Binary search for closest frame
  targetTime = atTime
  closestFrame = frames.first
  minDiff = infinity
  
  FOR frame in frames:
    diff = abs(frame.timestamp - targetTime)
    IF diff < minDiff:
      minDiff = diff
      closestFrame = frame
  
  return closestFrame
```

### 4. Update Poses on Time Change

```
In AnalysisView.onChange(of: currentTime):
  IF showSkeleton AND selectedShot exists:
    currentUserPose = getCurrentPoseFrame(
      selectedShot.paddedPoseFrames, 
      currentTime - selectedShot.startTime
    )
    
    IF isComparing AND proShot exists:
      // Calculate equivalent pro time
      userProgress = (currentTime - selectedShot.startTime) / selectedShot.duration
      proTime = proShot.startTime + (userProgress * proShot.duration)
      currentProPose = getCurrentPoseFrame(
        proShot.paddedPoseFrames,
        proTime - proShot.startTime
      )
```

### 5. Render Skeleton Overlays

```
In videoLayer overlay section:

IF showSkeleton:
  // Hide trajectory overlays
  
  IF isComparing:
    HStack(spacing: 1):
      // User video skeleton
      SkeletonOverlay(pose: currentUserPose)
        .frame(width: geometry.width / 2)
        .allowsHitTesting(false)
      
      // Pro video skeleton  
      SkeletonOverlay(pose: currentProPose)
        .frame(width: geometry.width / 2)
        .allowsHitTesting(false)
  ELSE:
    // Single video skeleton
    SkeletonOverlay(pose: currentUserPose)
      .allowsHitTesting(false)

ELSE:
  // Show trajectory overlays (existing code)
```

### 6. Handle State Transitions

```
onChange(of: showSkeleton):
  IF showSkeleton:
    // Initialize current poses
    updateCurrentPoses()
    // Clear trajectory cache to free memory
    trajectoryCache.removeAll()
  ELSE:
    // Clear pose references
    currentUserPose = nil
    currentProPose = nil
```

---

## Key Design Decisions

**Minimalism Choices**:
1. Reuse existing SkeletonOverlay - no new rendering code
2. Skeleton as exclusive option - can't show with trajectories (simpler state)
3. Use binary search for frame lookup - O(log n) performance
4. Piggyback on existing playback time updates - no new timers

**Memory Optimization**:
- Only store current frame references, not full skeleton paths
- Clear trajectory cache when showing skeletons
- Poses already loaded in paddedPoseFrames

**UX Considerations**:
- Skeleton updates live during playback
- Synchronized between user/pro videos
- Clear visual distinction from trajectory mode

---

## Testing Checklist

- [ ] Skeleton option appears in selector
- [ ] Selecting skeleton hides trajectories
- [ ] Skeleton updates smoothly during playback
- [ ] Compare mode shows both skeletons
- [ ] Switching between options works cleanly
- [ ] Performance acceptable on older devices
- [ ] Memory usage stays reasonable