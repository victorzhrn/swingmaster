## Swing Validation Restructure — MVP Slim Plan (1 image + per-frame metrics)

This plan replaces the current 8-frame image validation with 1 peak-frame image + CSV time-series data for ALL frames. Focus: **impactful metrics that are easy to compute** for MVP delivery.

### What changes
- **1 image total**: render only the peak-velocity frame as a skeleton PNG.
- **CSV for all frames**: compact, token-efficient, ordered by frame index.
- **Minimal metrics only** (impactful + easy to compute):
  - **Required**: idx, time, wristVel, wristX, wristY
  - **Helpful (low-cost)**: elbowAng, hipRot  
  - **High-impact equipment**: racketX, racketY, racketDist
- **Private metric type**: define `ValidationFrameMetric` as `fileprivate` inside `GeminiValidator` (no new Models file).
- **Delete sampling complexity**: remove all multi-image sampling and helpers.

### Implementation overview
1) Keep `ValidatedSwing` and parsing as-is. In `GeminiValidator`:
   - Remove `sampleFramesForValidation` and multi-frame `prepareImages` usage.
   - Add `fileprivate struct ValidationFrameMetric` with only essential fields.
   - Add `metricsToCSV(_:)` with minimal header:

```swift
idx,time,wristVel,wristX,wristY,elbowAng,hipRot,racketX,racketY,racketDist
```

   - Add `extractAllFrameMetrics(_:objectFrames:)` that:
     - Reuses existing `PotentialSwing.angularVelocities` (add this field to avoid recomputation).
     - Computes `wristX` as wrist relative to hip-center in [-1, +1], `wristY` as normalized 0..1.
     - Computes `elbowAng` (shoulder–elbow–wrist angle) and `hipRot` (hip line angle).
     - Pulls nearest `ObjectDetectionFrame` by timestamp for `racketX`, `racketY`, `racketDist`.
   - Build prompt with column explanation and call API with `[peakImage]` plus CSV text.

2) In `VideoProcessor`:
   - File pipeline: filter `objectFrames` by candidate time span and pass to validator.
   - Live pipeline: pass `objectFrames: []`.

3) Add `angularVelocities: [Float]` to `PotentialSwing` and slice from global metrics during segment extraction.

### CSV format (MVP)

Header:
```csv
idx,time,wristVel,wristX,wristY,elbowAng,hipRot,racketX,racketY,racketDist
```

Notes:
- Keep 2–3 decimals precision for compactness.
- Leave empty fields for missing racket data.
- Ensure `idx` is contiguous from 0.

Example (trimmed):
```csv
idx,time,wristVel,wristX,wristY,elbowAng,hipRot,racketX,racketY,racketDist
0,0.000,0.12,-0.30,0.45,1.20,-0.10,-0.35,0.47,0.15
1,0.033,0.18,-0.32,0.44,1.15,-0.12,-0.38,0.46,0.18
...
15,0.500,8.50,0.15,0.52,2.80,0.35,0.25,0.53,0.85
...
29,0.966,0.80,0.70,0.38,1.60,0.40,0.78,0.36,0.20
```

### Prompt (short, key-frame agnostic)

```swift
Analyze this tennis swing. The attached image is the peak-velocity frame.

CSV for all frames (columns):
- wristVel: wrist angular velocity (rad/s)
- wristX: wrist position relative to hip-center (-1=right, +1=left)
- wristY: wrist height (0=bottom, 1=top)
- elbowAng: shoulder–elbow–wrist angle (radians)
- hipRot: hip line angle (radians)
- racketX / racketY: racket center relative to body, height; may be empty if undetected
- racketDist: wrist-to-racket center distance (normalized)

Tasks:
1) Classify swing type (forehand/backhand) using wristX/racketX directional change and hipRot direction.
2) Find start/end and key frames by patterns:
   - preparation: low wristVel, small racketDist
   - backswing: wristX/racketX at extreme opposite of follow-through direction
   - contact: peak wristVel, large racketDist (typically 0.7+), wristY/racketY ~0.4-0.6
   - follow_through: wristX/racketX beyond contact, racketDist decreasing
   - recovery: velocities declining, return toward center
3) Return ONLY JSON with fields: is_valid_swing, swing_type, start_frame, end_frame, confidence, key_frames{preparation, backswing, contact, follow_through, recovery}
```

---

## Implementation Changes

### 1. Update `PotentialSwing` to include velocities

**File:** `swingmaster/Core/SwingDetector.swift`

Add `angularVelocities` field and slice from global metrics:

```swift
public struct PotentialSwing: Sendable {
    public let frames: [PoseFrame]
    public let peakFrameIndex: Int
    public let peakVelocity: Float
    public let timestamp: TimeInterval
    + public let angularVelocities: [Float]  // Slice from global metrics
}

// In extractSegment method:
let subframes = Array(frames[startIndex...endIndex])
+ let subVelocities = Array(metrics.angularVelocities[startIndex...endIndex])
let localPeakIndex = max(0, min(peakIndex - startIndex, subframes.count - 1))

return PotentialSwing(frames: subframes,
                      peakFrameIndex: localPeakIndex,
                      peakVelocity: peakVelocity,
                      timestamp: ts,
+                     angularVelocities: subVelocities)
```

### 2. Modify `GeminiValidator.swift`

#### A. Add Private Metrics Structure

```swift
fileprivate struct ValidationFrameMetric {
    let index: Int
    let timestamp: Double
    let wristVelocity: Double
    let wristRelativeX: Double     // -1 (right) to +1 (left) of body
    let wristHeight: Double        // 0 (bottom) to 1 (top) normalized
    let elbowAngle: Double         // Shoulder-elbow-wrist angle (0-π radians)
    let hipRotation: Double        // Angle between hips (radians)
    let racketX: Double?           // Racket center X relative to body (-1 to +1)
    let racketY: Double?           // Racket center Y (0 to 1)
    let racketWristDist: Double?   // Distance from racket to wrist (normalized)
}
```

#### B. Replace validateSwing Method

```swift
public func validateSwing(_ potential: PotentialSwing,
                         objectFrames: [ObjectDetectionFrame] = []) async throws -> ValidatedSwing? {
    // Get peak frame for single image
    let peakFrame = potential.frames[potential.peakFrameIndex]
    let peakImage = try await renderSingleFrame(peakFrame)
    
    // Extract metrics for ALL frames including racket data
    let metrics = extractAllFrameMetrics(potential, objectFrames: objectFrames)
    let csvData = metricsToCSV(metrics)
    
    // Simple prompt with CSV data
    let prompt = makeCSVPrompt(csv: csvData, peakIndex: potential.peakFrameIndex)
    
    // API call with 1 image + CSV text
    let response = try await callGeminiAPI(images: [peakImage], prompt: prompt)
    
    // Parse response (unchanged)
    guard let parsed = parseValidationResponse(response), parsed.isValid else {
        return nil
    }
    
    // Return validated swing (unchanged)
    // ... existing code for creating ValidatedSwing
}
```

#### C. Add CSV Conversion

```swift
private func metricsToCSV(_ metrics: [ValidationFrameMetric]) -> String {
    var csv = "idx,time,wristVel,wristX,wristY,elbowAng,hipRot,racketX,racketY,racketDist\n"
    for m in metrics {
        csv += "\(m.index),"
        csv += String(format: "%.3f,", m.timestamp)
        csv += String(format: "%.2f,", m.wristVelocity)
        csv += String(format: "%.2f,", m.wristRelativeX)
        csv += String(format: "%.2f,", m.wristHeight)
        csv += String(format: "%.2f,", m.elbowAngle)
        csv += String(format: "%.2f,", m.hipRotation)
        
        // Racket metrics (may be nil if not detected)
        if let rx = m.racketX {
            csv += String(format: "%.2f,", rx)
        } else {
            csv += ","
        }
        
        if let ry = m.racketY {
            csv += String(format: "%.2f,", ry)
        } else {
            csv += ","
        }
        
        if let rd = m.racketWristDist {
            csv += String(format: "%.2f", rd)
        } else {
            csv += ""
        }
        
        csv += "\n"
    }
    return csv
}
```

#### D. Extract Metrics for ALL Frames

```swift
private func extractAllFrameMetrics(_ potential: PotentialSwing,
                                   objectFrames: [ObjectDetectionFrame]) -> [ValidationFrameMetric] {
    return potential.frames.enumerated().map { index, frame in
        // Get key joints with defaults
        let rightWrist = frame.joints[.rightWrist] ?? CGPoint(x: 0.5, y: 0.5)
        let rightElbow = frame.joints[.rightElbow] ?? CGPoint(x: 0.55, y: 0.55)
        let rightShoulder = frame.joints[.rightShoulder] ?? CGPoint(x: 0.6, y: 0.6)
        let leftHip = frame.joints[.leftHip] ?? CGPoint(x: 0.4, y: 0.4)
        let rightHip = frame.joints[.rightHip] ?? CGPoint(x: 0.6, y: 0.4)
        
        // Body center (average of hips)
        let centerX = (leftHip.x + rightHip.x) / 2
        
        // Find matching object detection frame (closest timestamp)
        let objectFrame = findClosestObjectFrame(
            timestamp: frame.timestamp,
            in: objectFrames
        )
        
        // Calculate racket metrics if detected
        var racketX: Double? = nil
        var racketY: Double? = nil
        var racketWristDist: Double? = nil
        
        if let racket = objectFrame?.racket {
            let racketCenter = CGPoint(
                x: racket.boundingBox.midX,
                y: racket.boundingBox.midY
            )
            
            racketX = max(-1, min(1, (racketCenter.x - centerX) * 2))  // Clamp to [-1, 1]
            racketY = racketCenter.y
            
            let dist = sqrt(
                pow(racketCenter.x - rightWrist.x, 2) +
                pow(racketCenter.y - rightWrist.y, 2)
            )
            racketWristDist = dist
        }
        
        // Hip rotation (angle in radians)
        let hipRot = atan2(
            rightHip.y - leftHip.y,
            rightHip.x - leftHip.x
        )
        
        // Elbow angle (shoulder-elbow-wrist angle)
        let elbowAng = calculateAngleBetweenPoints(
            p1: rightShoulder,
            p2: rightElbow,
            p3: rightWrist
        )
        
        // Wrist position relative to center (-1 to +1)
        let wristRelX = max(-1, min(1, (rightWrist.x - centerX) * 2))
        
        // Reuse existing velocity from PotentialSwing
        let velocity = index < potential.angularVelocities.count ? 
                      Double(potential.angularVelocities[index]) : 0.0
        
        return ValidationFrameMetric(
            index: index,
            timestamp: frame.timestamp,
            wristVelocity: velocity,
            wristRelativeX: wristRelX,
            wristHeight: rightWrist.y,
            elbowAngle: elbowAng,
            hipRotation: hipRot,
            racketX: racketX,
            racketY: racketY,
            racketWristDist: racketWristDist
        )
    }
}

// Helper methods
private func findClosestObjectFrame(timestamp: TimeInterval,
                                   in frames: [ObjectDetectionFrame]) -> ObjectDetectionFrame? {
    return frames.min(by: { abs($0.timestamp - timestamp) < abs($1.timestamp - timestamp) })
}

private func calculateAngleBetweenPoints(p1: CGPoint, p2: CGPoint, p3: CGPoint) -> Double {
    let v1 = CGPoint(x: p1.x - p2.x, y: p1.y - p2.y)
    let v2 = CGPoint(x: p3.x - p2.x, y: p3.y - p2.y)
    
    let dot = v1.x * v2.x + v1.y * v2.y
    let det = v1.x * v2.y - v1.y * v2.x
    
    return abs(atan2(det, dot))  // Return angle in radians (0 to π)
}

private func renderSingleFrame(_ frame: PoseFrame) async throws -> String {
    if let data = Self.renderSkeletonPNG(frame: frame, width: 480, height: 480) {
        return data.base64EncodedString()
    }
    return ""
}
```

### 3. Update VideoProcessor Integration

**File:** `swingmaster/Core/VideoProcessor.swift`

Update both file and live processing paths:

```swift
// In processVideo method (around line 133):
for (idx, candidate) in potentialSwings.enumerated() {
    self.state = .validatingSwings(current: idx + 1, total: potentialSwings.count)
    
    // Find object frames that align with this candidate's timespan
    let candidateStart = candidate.frames.first?.timestamp ?? 0
    let candidateEnd = candidate.frames.last?.timestamp ?? 0
    let relevantObjectFrames = objectFrames.filter { 
        $0.timestamp >= candidateStart && $0.timestamp <= candidateEnd 
    }
    
    // Pass object frames to validator
    if let vs = try? await geminiValidator.validateSwing(
        candidate, 
        objectFrames: relevantObjectFrames
    ) {
        validated.append(vs)
    }
}

// In processLiveSession method (around line 194):
// Pass empty array for live sessions
if let vs = try? await geminiValidator.validateSwing(candidate, objectFrames: []) {
    validated.append(vs)
}
```

---

## Code to DELETE

### In `GeminiValidator.swift`:

1. **DELETE** `sampleFramesForValidation()` method (~40 lines)
2. **DELETE** multi-frame `prepareImages()` usage
3. **DELETE** old `makeValidationPrompt()` with frame indices (~50 lines)
4. **DELETE** all sampling-related logic

**Net result**: ~90 lines removed, ~60 lines added = **30 lines reduction + simpler logic**

---

## Expected Improvements

| Metric | Before | After | Impact |
|--------|--------|-------|--------|
| Images sent | 8 | 1 | ⬇️ 87.5% |
| Text tokens | ~1,650 | ~450 | ⬇️ 73% |
| Total API cost | $0.08 | $0.02 | ⬇️ 75% |
| Response time | 2-3s | 0.5-1s | ⬇️ 66% |
| Code complexity | High | Low | Simplified |
| Data completeness | 8 frames | ALL frames | ⬆️ 300% |

---

## Rationale for Slim MVP Set

**Required metrics (always compute):**
- `idx, time, wristVel, wristX, wristY` - Core swing motion and timing

**Helpful metrics (low computation cost):**
- `elbowAng` - Extension quality (key swing indicator)
- `hipRot` - Body rotation (distinguishes swing types)

**High-impact equipment metrics:**
- `racketX, racketY, racketDist` - Precise contact point and extension

This minimal set captures the essential swing dynamics while keeping computation simple and CSV compact. Additional metrics can be added later based on validation results.