# AnalysisView Redesign Implementation Plan

## Executive Summary
Transform AnalysisView from a scrollable layout to an immersive, full-screen video experience with overlay controls. The video becomes the canvas, with metrics at top, trajectory controls at bottom, and the existing timeline component preserved.

## Visual Design Mock

### Default State (What Users See Immediately)
```
┌──────────────────────────────────────────┐
│  ╔═══════════════════════════════════╗   │ ← Compact metrics (always visible)
│  ║ FOREHAND • ⚡15 🔄143° 🎯68% ↗️70% ║   │   
│  ╚═══════════════════════════════════╝   │
│                                          │
│                                          │
│         [100% VIDEO VIEWPORT]            │
│                                          │
│     [Trajectories ACTIVELY SHOWING]      │ ← Visible by default
│         ━━━━━🟡━━━━━                     │   (wrist + racket)
│              ╱                           │
│             ●                            │
│                                          │
│  ┌─────────────────────────────────────┐ │ ← Trajectory controls
│  │     ✋    🎾    💪    👁    ⚪      │ │   (SF Symbol icons)
│  └─────────────────────────────────────┘ │
├──────────────────────────────────────────┤
│  ◀◀  ━━━━━●━━◇━━●━━◎━━●━━━◇━━━━●━━  ▶▶ │ ← Timeline + Nav
│         Shot 3 of 7 • Forehand           │
└──────────────────────────────────────────┘
```

### Metrics Expanded State (After Tap)
```
┌──────────────────────────────────────────┐
│  ╔════════════════════════════════════╗   │
│  ║        FOREHAND ANALYSIS    [X]    ║   │ ← Expanded (2-column)
│  ║  ─────────────────────────────────  ║   │
│  ║  ⚡ Peak Speed    15 rad/s          ║   │
│  ║  🔄 Shoulder     143°               ║   │
│  ║  🎯 Contact      68%                ║   │
│  ║  ↗️ Follow       70%                ║   │
│  ║  ✅ Quality      69%                ║   │
│  ╚════════════════════════════════════╝   │
│                                          │
│         [Video continues playing]        │
│                                          │
│  ┌─────────────────────────────────────┐ │
│  │     ✋    🎾    💪    👁    ⚪      │ │
│  └─────────────────────────────────────┘ │
├──────────────────────────────────────────┤
│  ◀◀  ━━━━━●━━◇━━●━━◎━━●━━━◇━━━━●━━  ▶▶ │
└──────────────────────────────────────────┘
```

## Architecture Changes

### Current Structure (ScrollView-based)
```
ScrollView
└── VStack
    ├── VideoPlayer (320pt height)
    ├── TimelineStripEnhanced
    └── MetricsCard
```

### New Structure (ZStack-based)
```
ZStack (Full Screen)
├── Layer 0: VideoPlayer (100% viewport)
├── Layer 1: TrajectoryOverlay (existing)
├── Layer 2: SwingMetricsBar (top overlay)
├── Layer 3: TrajectorySelector (bottom overlay)
└── Layer 4: TimelineStripEnhanced (bottom)
```

**Key Point**: Each UI component is an independent overlay layer on the video, not contained within a VStack.

---

## Phase 1: Video Component Resizing

### 1.1 Transform AnalysisView Layout

**File:** `Views/AnalysisView.swift` (Direct modification)

**Changes:**
- Replace root `ScrollView` with `GeometryReader` and `ZStack`
- Remove fixed 320pt height constraint on video
- Make each UI element a separate overlay layer

**Implementation:**
```swift
var body: some View {
    GeometryReader { geometry in
        ZStack {
            // Base Layer: Full-screen video
            videoLayer(geometry: geometry)
            
            // Overlay Layer 1: Trajectory visualization
            if let shot = shots.first(where: { $0.id == selectedShotID }) {
                TrajectoryOverlay(...)
                    .allowsHitTesting(false)
            }
            
            // Overlay Layer 2: Metrics bar (top)
            VStack {
                SwingMetricsBar(shot: currentShot)
                    .padding(.top, geometry.safeAreaInsets.top)
                Spacer()
            }
            
            // Overlay Layer 3: Controls (bottom)
            VStack {
                Spacer()
                VStack(spacing: 0) {
                    TrajectorySelector(
                        enabledTrajectories: $enabledTrajectories,
                        trajectoryOptions: $trajectoryOptions
                    )
                    TimelineStripEnhanced(...)
                }
                .padding(.bottom, geometry.safeAreaInsets.bottom)
            }
        }
        .ignoresSafeArea(.container, edges: .all)
    }
}
```

### 1.2 Video Layer Implementation

```swift
@ViewBuilder
private func videoLayer(geometry: GeometryProxy) -> some View {
    Group {
        if let url = videoURL {
            VideoPlayerView(
                url: url,
                currentTime: $currentTime,
                isPlaying: $isPlaying,
                segmentStart: playingSegment?.startTime,
                segmentEnd: playingSegment?.endTime,
                onSegmentComplete: { playingSegment = nil }
            )
            // Fill entire screen, no decorations
        } else {
            // Full-screen placeholder
            ZStack {
                Color.black
                VStack(spacing: 12) {
                    Image(systemName: "play.rectangle.fill")
                        .font(.system(size: 48))
                        .foregroundColor(.white.opacity(0.3))
                    Text(timeString(currentTime) + " / " + timeString(duration))
                        .font(.system(size: 16, weight: .medium, design: .monospaced))
                        .foregroundColor(.white.opacity(0.5))
                }
            }
        }
    }
}
```

---

## Phase 2: SwingMetricsBar Component

### 2.1 Create SwingMetricsBar Component

**New File:** `Components/SwingMetricsBar.swift`

**Design Specs:**
- Compact: Single-line horizontal layout (44pt height)
- Expanded: Compact 2-column grid (120pt height)
- No progress bars - just icons and values
- Glass morphism background

### 2.2 Compact View Implementation

```swift
struct SwingMetricsBar: View {
    let shot: Shot?
    @State private var isExpanded: Bool = false
    
    private var metrics: SegmentMetrics? {
        shot?.segmentMetrics
    }
    
    var body: some View {
        Group {
            if isExpanded {
                expandedView()
            } else {
                compactView()
            }
        }
        .animation(.spring(response: 0.25, dampingFraction: 0.85), value: isExpanded)
    }
    
    private func compactView() -> some View {
        HStack(spacing: 10) {
            // Shot type
            Text(shot?.type.accessibleName.uppercased() ?? "SHOT")
                .font(.system(size: 13, weight: .semibold))
                .foregroundColor(.primary)
            
            Text("•")
                .foregroundColor(.secondary.opacity(0.4))
            
            // Inline metrics
            Group {
                metricPill(icon: "bolt.fill", 
                          value: "\(Int(metrics?.peakAngularVelocity ?? 0))",
                          color: .orange)
                
                metricPill(icon: "arrow.triangle.2.circlepath",
                          value: "\(Int(metrics?.backswingAngle ?? 0))°",
                          color: .blue)
                
                metricPill(icon: "target",
                          value: "\(Int((metrics?.contactPoint.y ?? 0) * 100))%",
                          color: .green)
                
                metricPill(icon: "arrow.up.right",
                          value: "\(Int((metrics?.followThroughHeight ?? 0) * 100))%",
                          color: .purple)
            }
            
            Spacer()
            
            // Expand button
            Image(systemName: "chevron.down.circle")
                .font(.system(size: 14))
                .foregroundColor(.secondary.opacity(0.5))
        }
        .padding(.horizontal, 16)
        .frame(height: 44)
        .background(.regularMaterial)
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .padding(.horizontal, 12)
        .onTapGesture {
            withAnimation { isExpanded = true }
        }
    }
    
    @ViewBuilder
    private func metricPill(icon: String, value: String, color: Color) -> some View {
        HStack(spacing: 3) {
            Image(systemName: icon)
                .font(.system(size: 11))
                .foregroundColor(color)
            Text(value)
                .font(.system(size: 12, weight: .medium, design: .monospaced))
        }
    }
}
```

### 2.3 Expanded View Implementation (2-Column Layout)

```swift
private func expandedView() -> some View {
    VStack(spacing: 0) {
        // Header
        HStack {
            Text("\(shot?.type.accessibleName.uppercased() ?? "SHOT") ANALYSIS")
                .font(.system(size: 14, weight: .bold))
            Spacer()
            Button(action: { withAnimation { isExpanded = false } }) {
                Image(systemName: "xmark.circle.fill")
                    .font(.system(size: 18))
                    .foregroundColor(.secondary.opacity(0.6))
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 10)
        
        Divider().opacity(0.2)
        
        // 2-column metrics grid
        HStack(spacing: 24) {
            // Left column
            VStack(alignment: .leading, spacing: 8) {
                metricRow(icon: "bolt.fill",
                         label: "Peak Speed",
                         value: "\(Int(metrics?.peakAngularVelocity ?? 0)) rad/s",
                         color: .orange)
                
                metricRow(icon: "arrow.triangle.2.circlepath",
                         label: "Shoulder",
                         value: "\(Int(metrics?.backswingAngle ?? 0))°",
                         color: .blue)
                
                metricRow(icon: "target",
                         label: "Contact",
                         value: "\(Int((metrics?.contactPoint.y ?? 0) * 100))%",
                         color: .green)
            }
            
            // Right column  
            VStack(alignment: .leading, spacing: 8) {
                metricRow(icon: "arrow.up.right",
                         label: "Follow",
                         value: "\(Int((metrics?.followThroughHeight ?? 0) * 100))%",
                         color: .purple)
                
                metricRow(icon: "checkmark.circle.fill",
                         label: "Quality",
                         value: "\(Int((metrics?.averageConfidence ?? 0) * 100))%",
                         color: metrics?.averageConfidence ?? 0 > 0.7 ? .green : .orange)
            }
            
            Spacer()
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 10)
    }
    .frame(height: 120)
    .background(.regularMaterial)
    .clipShape(RoundedRectangle(cornerRadius: 12))
    .padding(.horizontal, 12)
    .transition(.asymmetric(
        insertion: .move(edge: .top).combined(with: .opacity),
        removal: .opacity
    ))
}

@ViewBuilder
private func metricRow(icon: String, label: String, value: String, color: Color) -> some View {
    HStack(spacing: 8) {
        Image(systemName: icon)
            .font(.system(size: 14))
            .foregroundColor(color)
            .frame(width: 20)
        
        VStack(alignment: .leading, spacing: 0) {
            Text(label)
                .font(.system(size: 11))
                .foregroundColor(.secondary)
            Text(value)
                .font(.system(size: 13, weight: .semibold, design: .monospaced))
        }
    }
}
```

---

## Phase 3: Transform TrajectorySelector

### 3.1 Update Existing TrajectorySelector Component

**File:** `Components/TrajectorySelector.swift` (Transform existing)

### 3.2 New Horizontal Strip Implementation

```swift
struct TrajectorySelector: View {
    @Binding var enabledTrajectories: Set<TrajectoryType>
    @Binding var trajectoryOptions: TrajectoryOptions
    
    @AppStorage("hasSeenTrajectoryLabels") private var hasSeenLabels = false
    @State private var showLabels = false
    @State private var showOptions = false
    
    // SF Symbol mappings for trajectory types
    private let trajectoryButtons: [(TrajectoryType, String, String)] = [
        (.rightWrist, "hand.raised.fill", "Wrist"),
        (.racketCenter, "sportscourt.fill", "Racket"),  
        (.rightElbow, "figure.arms.open", "Elbow"),
        (.rightShoulder, "person.fill", "Should"),
        (.ballCenter, "circle.fill", "Ball")
    ]
    
    var body: some View {
        HStack(spacing: 0) {
            // Centered trajectory toggles
            Spacer()
            
            HStack(spacing: 20) {
                ForEach(trajectoryButtons, id: \.0) { type, icon, label in
                    TrajectoryToggleButton(
                        type: type,
                        systemIcon: icon,
                        label: label,
                        isEnabled: enabledTrajectories.contains(type),
                        showLabel: showLabels || !hasSeenLabels,
                        onToggle: { toggleTrajectory(type) }
                    )
                }
            }
            
            Spacer()
            
            // Options button (right edge)
            Button(action: { showOptions.toggle() }) {
                Image(systemName: "slider.horizontal.3")
                    .font(.system(size: 16))
                    .foregroundColor(.secondary.opacity(0.7))
                    .frame(width: 40, height: 40)
                    .background(Circle().fill(Color.white.opacity(0.1)))
            }
            .padding(.trailing, 12)
        }
        .frame(height: 56)
        .background(.ultraThinMaterial)
        .overlay(
            Rectangle()
                .frame(height: 0.5)
                .foregroundColor(.white.opacity(0.15)),
            alignment: .top
        )
        .sheet(isPresented: $showOptions) {
            TrajectoryOptionsSheet(options: $trajectoryOptions)
                .presentationDetents([.height(200)])
        }
        .onAppear {
            if !hasSeenLabels {
                showLabelsTemporarily()
            }
        }
    }
    
    private func toggleTrajectory(_ type: TrajectoryType) {
        withAnimation(.spring(response: 0.2, dampingFraction: 0.85)) {
            if enabledTrajectories.contains(type) {
                enabledTrajectories.remove(type)
            } else {
                enabledTrajectories.insert(type)
            }
        }
        UIImpactFeedbackGenerator(style: .light).impactOccurred()
    }
    
    private func showLabelsTemporarily() {
        showLabels = true
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            withAnimation(.easeOut(duration: 0.3)) {
                showLabels = false
            }
            hasSeenLabels = true
        }
    }
}
```

### 3.3 TrajectoryToggleButton with SF Symbols

```swift
struct TrajectoryToggleButton: View {
    let type: TrajectoryType
    let systemIcon: String
    let label: String
    let isEnabled: Bool
    let showLabel: Bool
    let onToggle: () -> Void
    
    @State private var isPressed = false
    
    var body: some View {
        VStack(spacing: 4) {
            Button(action: {
                isPressed = true
                onToggle()
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    isPressed = false
                }
            }) {
                ZStack {
                    // Background circle
                    Circle()
                        .fill(isEnabled ? TennisColors.tennisGreen : Color.clear)
                        .overlay(
                            Circle()
                                .stroke(
                                    isEnabled ? Color.clear : Color.white.opacity(0.25),
                                    lineWidth: 1.5
                                )
                        )
                    
                    // SF Symbol icon
                    Image(systemName: systemIcon)
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(isEnabled ? .white : .white.opacity(0.5))
                }
                .frame(width: 40, height: 40)
                .scaleEffect(isPressed ? 0.9 : 1.0)
                .animation(.spring(response: 0.15), value: isPressed)
            }
            .buttonStyle(PlainButtonStyle())
            
            // Label (conditional)
            if showLabel {
                Text(label)
                    .font(.system(size: 10))
                    .foregroundColor(.secondary)
                    .transition(.opacity.combined(with: .scale))
            }
        }
        .frame(width: 44, height: 56)
    }
}
```

## Implementation Steps

### Day 1: Components
1. **Create SwingMetricsBar.swift**
   - Implement compact single-line view
   - Add 2-column expanded view (no progress bars)
   - Test animations between states

2. **Update TrajectorySelector.swift**
   - Transform to horizontal strip layout
   - Replace emojis with SF Symbols
   - Move options to separate sheet

### Day 2: Layout Transformation
1. **Modify AnalysisView.swift**
   - Replace ScrollView with ZStack layers
   - Each UI component as independent overlay
   - Full-screen video as base layer

2. **Remove video decorations**
   - No rounded corners
   - No shadows or borders
   - Fill entire viewport

### Day 3: Integration & Testing
1. **Wire up overlays**
   - SwingMetricsBar positioning at top
   - TrajectorySelector above timeline
   - Ensure proper safe area handling

2. **Test interactions**
   - Metrics expand/collapse
   - Trajectory toggles
   - Timeline navigation unchanged

### Day 4: Polish
1. **Fine-tune animations**
   - Spring parameters for smoothness
   - Haptic feedback timing
   - First-use label display

2. **Visual refinements**
   - Glass morphism consistency
   - SF Symbol sizes and weights
   - Dark mode adjustments

---

## Key Implementation Details

### Layer Structure in AnalysisView
```swift
ZStack {
    // Layer 0: Base
    VideoPlayer()
    
    // Layer 1: Content
    TrajectoryOverlay()
    
    // Layer 2: Top UI
    VStack {
        SwingMetricsBar()
        Spacer()
    }
    
    // Layer 3: Bottom UI
    VStack {
        Spacer()
        TrajectorySelector()
        TimelineStripEnhanced()
    }
}
```

### SF Symbol Configuration
```swift
Image(systemName: icon)
    .font(.system(size: 18, weight: .medium))
    .symbolRenderingMode(.hierarchical)
```

### Glass Morphism Consistency
```swift
.background(.regularMaterial)  // Metrics bar
.background(.ultraThinMaterial) // Trajectory selector
```

### Animation Timings
```swift
.spring(response: 0.25, dampingFraction: 0.85) // Metrics
.spring(response: 0.2, dampingFraction: 0.85)  // Trajectories
.spring(response: 0.15)  // Button feedback
```

---

## Testing Checklist

### Visual Tests
- [ ] Video fills entire screen without gaps
- [ ] Overlays don't block critical video content
- [ ] Safe areas respected on all devices
- [ ] 2-column metrics layout readable
- [ ] SF Symbols clear at all sizes

### Interaction Tests
- [ ] Metrics expand/collapse smoothly
- [ ] Trajectory toggles instant response
- [ ] Options sheet accessible
- [ ] Timeline navigation preserved
- [ ] Haptic feedback working

### Performance Tests
- [ ] 60fps video playback maintained
- [ ] No lag with overlays active
- [ ] Smooth trajectory rendering
- [ ] Memory stable during long sessions

---

## Success Metrics

- **Engagement**: 3x increase in trajectory usage
- **Comprehension**: 50% faster metric understanding
- **Video Focus**: 30% longer analysis sessions
- **Discoverability**: 90% find features without help