# AnalysisView Redesign Implementation Plan

## Phase 1: Critical Fixes (Day 1)
*These fixes ensure basic design system compliance*

### 1.1 Remove Forced Dark Mode
**File**: `AnalysisView.swift`
**Line**: 59
**Action**: Delete `.preferredColorScheme(.dark)`
**Impact**: Respects user's system preference

### 1.2 Fix Shot Type Colors
**File**: `Models/Shot.swift`
**Action**: Update `accentColor` computed property
```swift
var accentColor: Color {
    switch self {
    case .forehand: return TennisColors.tennisGreen
    case .backhand: return TennisColors.aceGreen
    case .serve: return TennisColors.clayOrange
    case .unknown: return Color.gray.opacity(0.6)
    }
}
```
**Impact**: Timeline markers use consistent tennis colors

### 1.3 Apply Typography System
**File**: `AnalysisView.swift`
**Line**: ~87 (score display)
**Change**:
```swift
// Before
.font(.system(size: 28, weight: .bold, design: .monospaced))

// After
.modifier(TennisTypography.MetricStyle())
```
**Impact**: Consistent metric display

### 1.4 Replace Generic Colors
**File**: `AnalysisView.swift`
**Actions**:
- Line ~95: `.foregroundColor(.green)` → `.foregroundColor(TennisColors.aceGreen)`
- Line ~100: `.fill(Color.green)` → `.fill(TennisColors.aceGreen)`
- Line ~115: `.foregroundColor(.yellow)` → `.foregroundColor(TennisColors.tennisYellow)`
**Impact**: Consistent color palette

---

## Phase 2: Navigation Simplification (Day 2)

### 2.1 Remove ShotChipsRow
**File**: `AnalysisView.swift`
**Action**: Delete line ~32 (entire ShotChipsRow component)
**Replacement**: Add minimal prev/next overlay
```swift
// New component: MinimalShotNavigator
private var shotNavigator: some View {
    HStack {
        Button(action: selectPrev) {
            Image(systemName: "chevron.left.circle.fill")
                .font(.system(size: 32))
                .foregroundColor(.white.opacity(0.8))
        }
        
        Spacer()
        
        Text("Shot \(currentShotIndex + 1) of \(shots.count)")
            .font(.system(size: 14, weight: .medium, design: .monospaced))
            .foregroundColor(.white.opacity(0.9))
        
        Spacer()
        
        Button(action: selectNext) {
            Image(systemName: "chevron.right.circle.fill")
                .font(.system(size: 32))
                .foregroundColor(.white.opacity(0.8))
        }
    }
    .padding(.horizontal, 20)
    .padding(.vertical, 8)
    .background(.ultraThinMaterial)
    .clipShape(Capsule())
}
```
**Position**: Overlay on video bottom
**Impact**: Single navigation method, cleaner UI

### 2.2 Create Scrollable Timeline for Multiple Shots
**File**: `TimelineStripEnhanced.swift`
**Problem**: Videos with many shots (10+) won't fit on screen width
**Solution**: Horizontally scrollable timeline with smart behaviors

#### Implementation Approach:
```swift
struct TimelineStripEnhanced: View {
    // New properties for scrolling
    @State private var scrollOffset: CGFloat = 0
    @State private var contentWidth: CGFloat = 0
    @State private var viewportWidth: CGFloat = 0
    @Namespace private var scrollNamespace
    
    // Minimum spacing between markers
    private let minMarkerSpacing: CGFloat = 40  // Ensures touch targets don't overlap
    
    var body: some View {
        ScrollViewReader { scrollProxy in
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 0) {
                    // Left padding
                    Color.clear.frame(width: 20)
                    
                    // Timeline content
                    timelineContent
                        .background(
                            GeometryReader { geo in
                                Color.clear.onAppear {
                                    contentWidth = geo.size.width
                                }
                            }
                        )
                    
                    // Right padding
                    Color.clear.frame(width: 20)
                }
            }
            .frame(height: bandHeight)
            .onChange(of: selectedShotID) { _, newID in
                // Auto-scroll to selected shot
                withAnimation(.spring(response: 0.3)) {
                    scrollProxy.scrollTo(newID, anchor: .center)
                }
            }
        }
        .overlay(scrollIndicators) // Visual hints for scrollability
    }
}
```

#### Key Features:

**1. Dynamic Width Calculation**
```swift
private var timelineWidth: CGFloat {
    let shotCount = CGFloat(shots.count)
    let minWidth = UIScreen.main.bounds.width - 40  // Screen width minus padding
    let calculatedWidth = shotCount * minMarkerSpacing
    
    // Use screen width for few shots, expand for many
    return max(minWidth, calculatedWidth)
}
```

**2. Scroll Indicators** (fade edges when scrollable)
```swift
private var scrollIndicators: some View {
    HStack {
        // Left scroll indicator
        if scrollOffset > 0 {
            LinearGradient(
                colors: [Color.black.opacity(0.3), Color.clear],
                startPoint: .leading,
                endPoint: .trailing
            )
            .frame(width: 30)
            .allowsHitTesting(false)
        }
        
        Spacer()
        
        // Right scroll indicator
        if contentWidth > viewportWidth && scrollOffset < (contentWidth - viewportWidth) {
            LinearGradient(
                colors: [Color.clear, Color.black.opacity(0.3)],
                startPoint: .leading,
                endPoint: .trailing
            )
            .frame(width: 30)
            .allowsHitTesting(false)
        }
    }
}
```

**3. Smart Auto-Centering**
```swift
private func handleShotSelection(_ shot: MockShot, in scrollProxy: ScrollViewProxy) {
    selectedShotID = shot.id
    
    // Auto-center the selected shot in viewport
    withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
        scrollProxy.scrollTo(shot.id, anchor: .center)
    }
    
    // Haptic feedback
    UIImpactFeedbackGenerator(style: .light).impactOccurred()
}
```

**4. Density Modes** (for extreme cases)
```swift
enum TimelineDensity {
    case comfortable  // < 10 shots: full labels, 40pt spacing
    case compact     // 10-20 shots: abbreviated labels, 30pt spacing  
    case dense       // 20+ shots: dots only, 20pt spacing
    
    static func determine(for count: Int) -> TimelineDensity {
        switch count {
        case 0..<10: return .comfortable
        case 10..<20: return .compact
        default: return .dense
        }
    }
}
```

#### Visual Adaptations by Shot Count:

**Few Shots (1-9)**:
- Full timeline width = screen width
- Markers evenly distributed
- All labels visible
- No scrolling needed

**Medium Shots (10-19)**:
- Timeline extends beyond screen
- Smooth horizontal scrolling
- Selected shot auto-centers
- Edge fading indicates more content

**Many Shots (20+)**:
- Compact mode: smaller markers
- Labels only on selection
- Minimum 20pt between markers
- Clear scroll affordances

#### Interaction Patterns:

1. **Tap marker** → Selects and auto-centers
2. **Drag timeline** → Scroll through shots
3. **Selected segment expands** → Shows duration
4. **Pinch to zoom** (future): Adjust timeline scale

#### Accessibility Enhancements:

```swift
.accessibilityScrollAction { edge in
    switch edge {
    case .leading:
        // Scroll to previous page of shots
        scrollToPreviousPage()
    case .trailing:
        // Scroll to next page of shots
        scrollToNextPage()
    default:
        break
    }
}
.accessibilityHint("Swipe to navigate through \(shots.count) shots")
```

**Impact**: 
- Scales from 1 to 100+ shots gracefully
- Maintains 44pt touch targets always
- Progressive disclosure based on density
- Smooth, predictable navigation

---

## Phase 3: Insight Card Redesign - Compact Always-Visible Format (Day 3)

### 3.1 Create Compact Insight Bar
**File**: `AnalysisView.swift`
**Principle**: Insights are the core value - always visible but space-efficient
**Implementation**:

#### Compact Insight Bar (Primary View)
```swift
private var compactInsightBar: some View {
    HStack(spacing: 16) {
        // Shot type & score
        HStack(spacing: 8) {
            Text(selectedShot?.type.shortLabel ?? "")
                .font(.system(size: 14, weight: .bold, design: .monospaced))
                .foregroundColor(.white.opacity(0.7))
            
            Text(String(format: "%.1f", selectedShot?.score ?? 0))
                .modifier(TennisTypography.MetricStyle())
                .foregroundColor(scoreColor(selectedShot?.score ?? 0))
        }
        
        Divider()
            .frame(height: 20)
            .background(Color.white.opacity(0.2))
        
        // Primary strength (if good score)
        if let selectedShot = selectedShot, selectedShot.score >= 7.0,
           let firstStrength = selectedShot.strengths?.first {
            Label {
                Text(truncatedText(firstStrength, maxLength: 30))
                    .font(.system(size: 13, weight: .medium))
                    .foregroundColor(TennisColors.aceGreen)
            } icon: {
                Image(systemName: "checkmark.circle.fill")
                    .font(.system(size: 12))
                    .foregroundColor(TennisColors.aceGreen)
            }
        }
        
        // Primary improvement (always show)
        if let firstImprovement = selectedShot?.improvements?.first {
            Label {
                Text(truncatedText(firstImprovement, maxLength: 35))
                    .font(.system(size: 13, weight: .medium))
                    .foregroundColor(TennisColors.tennisYellow)
            } icon: {
                Image(systemName: "arrow.right.circle.fill")
                    .font(.system(size: 12))
                    .foregroundColor(TennisColors.tennisYellow)
            }
        }
        
        Spacer()
        
        // Detail toggle
        Button(action: { showDetailedInsights.toggle() }) {
            Image(systemName: "info.circle")
                .font(.system(size: 18))
                .foregroundColor(.white.opacity(0.6))
        }
    }
    .padding(.horizontal, 16)
    .padding(.vertical, 12)
    .background(
        RoundedRectangle(cornerRadius: 12)
            .fill(Color(UIColor.secondarySystemBackground))
    )
}
```

### 3.2 Progressive Detail Disclosure
**New State**: `@State private var showDetailedInsights = false`
**Context-Aware Display**:

```swift
private var adaptiveInsightDisplay: some View {
    VStack(spacing: 8) {
        // Always show compact bar
        compactInsightBar
        
        // Show details based on context
        if showDetailedInsights && !isPlaying {
            detailedInsightPanel
                .transition(.asymmetric(
                    insertion: .move(edge: .bottom).combined(with: .opacity),
                    removal: .move(edge: .bottom).combined(with: .opacity)
                ))
        }
    }
}

private var detailedInsightPanel: some View {
    VStack(alignment: .leading, spacing: 12) {
        // All strengths
        if let strengths = selectedShot?.strengths, !strengths.isEmpty {
            VStack(alignment: .leading, spacing: 6) {
                Label("Strengths", systemImage: "checkmark.circle.fill")
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundColor(TennisColors.aceGreen.opacity(0.8))
                
                ForEach(strengths, id: \.self) { strength in
                    HStack(alignment: .top, spacing: 8) {
                        Circle()
                            .fill(TennisColors.aceGreen)
                            .frame(width: 3, height: 3)
                            .offset(y: 5)
                        Text(strength)
                            .font(.system(size: 13))
                            .foregroundColor(.primary)
                    }
                }
            }
        }
        
        // All improvements
        if let improvements = selectedShot?.improvements, !improvements.isEmpty {
            VStack(alignment: .leading, spacing: 6) {
                Label("Focus Areas", systemImage: "arrow.triangle.2.circlepath")
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundColor(TennisColors.tennisYellow.opacity(0.8))
                
                ForEach(Array(improvements.enumerated()), id: \.offset) { index, improvement in
                    HStack(alignment: .top, spacing: 8) {
                        Circle()
                            .fill(TennisColors.tennisYellow.opacity(index == 0 ? 1 : 0.6))
                            .frame(width: 3, height: 3)
                            .offset(y: 5)
                        Text(improvement)
                            .font(.system(size: 13, weight: index == 0 ? .medium : .regular))
                            .foregroundColor(.primary.opacity(index == 0 ? 1 : 0.9))
                    }
                }
            }
        }
    }
    .padding(14)
    .background(
        RoundedRectangle(cornerRadius: 12)
            .fill(Color(UIColor.tertiarySystemBackground))
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(Color.white.opacity(0.1), lineWidth: 1)
            )
    )
    .padding(.horizontal, 16)
}
```

### 3.3 Video Overlay Elements
**Add floating indicators on video for immediate context**:

```swift
private var videoWithOverlays: some View {
    VideoPlayerView(...)
        .overlay(alignment: .topTrailing) {
            // Floating score badge
            if let score = selectedShot?.score {
                ScoreBadge(score: score)
                    .padding(12)
            }
        }
        .overlay(alignment: .bottomLeading) {
            // Primary insight pill (only when playing)
            if isPlaying, let improvement = selectedShot?.improvements?.first {
                InsightPill(text: truncatedText(improvement, maxLength: 25))
                    .padding(12)
            }
        }
}

struct ScoreBadge: View {
    let score: Float
    
    var body: some View {
        Text(String(format: "%.1f", score))
            .font(.system(size: 20, weight: .bold, design: .monospaced))
            .foregroundColor(.white)
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
            .background(
                Capsule()
                    .fill(scoreColor(score).opacity(0.9))
                    .overlay(
                        Capsule()
                            .stroke(Color.white.opacity(0.3), lineWidth: 1)
                    )
            )
            .shadow(radius: 4)
    }
}

struct InsightPill: View {
    let text: String
    
    var body: some View {
        HStack(spacing: 6) {
            Image(systemName: "arrow.right.circle.fill")
                .font(.system(size: 14))
            Text(text)
                .font(.system(size: 13, weight: .medium))
        }
        .foregroundColor(.white)
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(
            Capsule()
                .fill(TennisColors.tennisYellow.opacity(0.85))
        )
        .shadow(radius: 4)
    }
}
```

### 3.4 Behavioral Rules
**Context-Sensitive Display**:

```swift
// State management
@State private var showDetailedInsights = false

// Auto-hide details when playing
.onChange(of: isPlaying) { _, playing in
    if playing {
        withAnimation(.easeOut(duration: 0.2)) {
            showDetailedInsights = false
        }
    }
}

// Show details on shot change (briefly)
.onChange(of: selectedShotID) { _, _ in
    showDetailedInsights = true
    
    // Auto-hide after 3 seconds if playing
    if isPlaying {
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            withAnimation {
                showDetailedInsights = false
            }
        }
    }
}
```

### 3.5 Space Optimization
**Layout Hierarchy**:
```swift
VStack(spacing: 8) {
    // Video takes 60% of available height
    VideoWithOverlays()
        .frame(height: screenHeight * 0.6)
    
    // Timeline - 56pt fixed
    TimelineStripEnhanced(...)
    
    // Compact insight bar - 44pt when collapsed
    // Expands to ~120pt with details
    adaptiveInsightDisplay
    
    // Remaining space
    Spacer()
}
```

**Impact**:
- Insights always visible (core value preserved)
- Compact format saves ~60% vertical space
- Progressive disclosure based on user action
- Video overlays provide context without taking space
- Automatic adaptation during playback

---

## Phase 4: Video Controls Refinement (Day 4)

### 4.1 Persistent Mini Controls
**File**: `AnalysisView.swift`
**Replace**: Tap-to-show behavior
**New Design**:
```swift
private var persistentVideoControls: some View {
    HStack(spacing: 16) {
        // Play/Pause (always visible)
        Button(action: togglePlayback) {
            Image(systemName: isPlaying ? "pause.circle.fill" : "play.circle.fill")
                .font(.system(size: 36))
                .foregroundColor(.white.opacity(0.9))
                .background(
                    Circle()
                        .fill(Color.black.opacity(0.3))
                        .blur(radius: 10)
                )
        }
        
        // Current segment info (if playing)
        if let segment = playingSegment {
            Text(segment.type.shortLabel)
                .font(.system(size: 12, weight: .bold, design: .monospaced))
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(
                    Capsule()
                        .fill(segment.type.accentColor.opacity(0.8))
                )
                .foregroundColor(.white)
        }
    }
    .padding(12)
}
```
**Position**: Bottom-left of video
**Behavior**: Always visible, no auto-hide
**Impact**: Predictable, accessible controls

### 4.2 Remove Redundant Overlay
**Action**: Delete `showPlaybackControls` state and related logic
**Keep**: Only the persistent mini controls
**Impact**: Simpler state management

---

## Phase 5: Layout Optimization (Day 5)

### 5.1 Responsive Video Height
**Current**: Fixed 320pt
**New**: Dynamic based on device
```swift
private var videoHeight: CGFloat {
    let screenHeight = UIScreen.main.bounds.height
    if screenHeight < 700 { // iPhone SE
        return 280
    } else if screenHeight < 850 { // Standard iPhone
        return 320
    } else { // Max/Plus phones
        return 380
    }
}
```
**Impact**: Better use of screen real estate

### 5.2 Reorder Components
**Current Order**:
1. Video
2. Timeline
3. Chips (to remove)
4. Insights

**New Order**:
1. Video with overlay controls
2. Timeline (primary navigation)
3. Shot navigator (prev/next only)
4. Collapsible insights

**Implementation**:
```swift
var body: some View {
    VStack(spacing: 0) {
        // Video with overlays
        ZStack(alignment: .bottom) {
            VideoPlayerView(...)
                .frame(height: videoHeight)
            
            VStack(spacing: 12) {
                persistentVideoControls
                TimelineStripEnhanced(...)
            }
            .padding(.bottom, 16)
        }
        
        // Shot navigator
        shotNavigator
            .padding(.vertical, 8)
        
        // Insights (collapsible)
        collapsibleInsightCard
            .padding(.horizontal, 16)
        
        Spacer()
    }
    .background(Color(UIColor.systemBackground)) // Adaptive
}
```

### 5.3 Remove ScrollView
**Current**: Entire view in ScrollView
**Issue**: Unnecessary for this layout
**Action**: Remove ScrollView wrapper
**Impact**: More stable layout, better gesture handling

---

## Phase 6: Polish & Animation (Day 6)

### 6.1 Add Smooth Transitions
**Timeline Selection**:
```swift
withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
    selectedShotID = shot.id
}
```

**Insight Expansion**:
```swift
.animation(.spring(response: 0.4, dampingFraction: 0.75), value: insightExpanded)
```

### 6.2 Haptic Feedback
**Add to**:
- Shot selection (light impact)
- Segment playback start (medium impact)
- Score threshold changes (success haptic)

### 6.3 Loading States
**For video loading**:
```swift
if videoURL != nil && !isVideoLoaded {
    ProgressView()
        .progressViewStyle(CircularProgressViewStyle(tint: TennisColors.tennisGreen))
}
```

---

## Testing Checklist

### Visual Testing
- [ ] Light mode appearance correct
- [ ] Dark mode appearance correct
- [ ] Timeline colors match shot types
- [ ] No glass morphism violations
- [ ] Typography consistent

### Interaction Testing
- [ ] Timeline navigation smooth
- [ ] Prev/next buttons work
- [ ] Insight card collapse/expand
- [ ] Video controls always accessible
- [ ] Segment playback auto-stops

### Device Testing
- [ ] iPhone SE (small)
- [ ] iPhone 15 (standard)
- [ ] iPhone 15 Pro Max (large)
- [ ] iPad (if supported)
- [ ] Landscape orientation

### Accessibility Testing
- [ ] VoiceOver navigation
- [ ] Dynamic Type support
- [ ] Reduce Motion respected
- [ ] Color blind safe

---

## Migration Strategy

### Step 1: Create Feature Branch
```bash
git checkout -b feature/analysis-view-redesign
```

### Step 2: Implement Phase 1 (Critical Fixes)
- Test thoroughly
- Commit with message: "fix: Apply design system to AnalysisView"

### Step 3: Implement Phase 2 (Navigation)
- Test navigation flow
- Commit: "refactor: Simplify AnalysisView navigation"

### Step 4: Implement Phase 3-4 (Insights & Controls)
- Test collapsible behavior
- Commit: "feat: Add collapsible insights and persistent controls"

### Step 5: Implement Phase 5-6 (Layout & Polish)
- Test on all devices
- Commit: "polish: Optimize AnalysisView layout and animations"

### Step 6: Code Review
- PR with before/after screenshots
- Test on physical devices
- Get team feedback

### Step 7: Merge
```bash
git merge feature/analysis-view-redesign
```

---

## Success Metrics

### Quantitative
- Navigation actions reduced by 50%
- Time to understand shot: < 3 seconds
- Screen space for video increased by 30%

### Qualitative
- Users find navigation intuitive
- Video remains the hero element
- Insights are helpful but not intrusive

---

## Future Enhancements

### v2.0 Considerations
1. **Swipe gestures** on video for prev/next
2. **Picture-in-picture** mode
3. **AI overlay drawings** on video
4. **Export/share** functionality
5. **Comparison mode** (two swings side-by-side)

---

## Code Snippets for Quick Implementation

### Updated Score Color Function
```swift
private func scoreColor(_ score: Float) -> Color {
    if score >= 7.5 { return TennisColors.aceGreen }
    if score >= 5.5 { return TennisColors.tennisYellow }
    return TennisColors.clayOrange
}
```

### Adaptive Background
```swift
.background(Color(UIColor.systemBackground))
// Instead of
.background(Color.black)
```

### Remove Forced Dark Mode
```swift
// Delete this line entirely:
.preferredColorScheme(.dark)
```

---

## Notes

- Keep commits atomic and well-documented
- Test each phase before moving to next
- Document any deviations from plan
- Consider A/B testing major changes