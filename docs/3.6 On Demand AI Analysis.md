# On-Demand AI Analysis Implementation Plan

## Overview
Transform video processing from "analyze-all-upfront" to "analyze-on-demand" with minimal changes. Total estimated time: **6-8 hours**.

---

## Phase 1: Simplify Video Processing (1.5 hours)

### 1.1 Remove AI Analysis from VideoProcessor
**File:** `Core/VideoProcessor.swift`

```swift
// REMOVE the entire "Analyze validated swings" section (lines ~95-110)
// REPLACE with simple Shot creation:

// After validation loop, instead of analysis:
var results: [AnalysisResult] = []
for swing in validated {
    let segmentMetrics = metricsCalculator.calculateSegmentMetrics(for: swing.frames)
    
    // Create minimal AnalysisResult without AI feedback
    let result = AnalysisResult(
        segment: SwingSegment(
            startTime: swing.frames.first?.timestamp ?? 0,
            endTime: swing.frames.last?.timestamp ?? 0,
            frames: swing.frames
        ),
        swingType: swing.type,
        score: estimateBasicScore(metrics: segmentMetrics), // Add this method
        strengths: [],      // Empty for now
        improvements: [],   // Empty for now
        keyFrames: []      // Can populate from swing.keyFrameIndices if needed
    )
    results.append(result)
}

// ADD helper method:
private func estimateBasicScore(metrics: SegmentMetrics) -> Float {
    // Simple heuristic based on velocity and confidence
    let velocityScore = min(10, metrics.peakAngularVelocity / 2)
    let confidenceBonus = metrics.averageConfidence * 2
    return min(10, max(0, velocityScore + confidenceBonus))
}
```

### 1.2 Update Processing States
**File:** `Models/Session.swift`

```swift
// REMOVE analyzingSwings case from ProcessingStatus enum
enum ProcessingStatus: Codable {
    case pending
    case extractingPoses(progress: Float)
    case calculatingMetrics
    case detectingSwings  
    case validatingSwings(current: Int, total: Int)
    // case analyzingSwings(current: Int, total: Int) ← REMOVE
    case complete
    case failed(error: String)
    
    var statusText: String {
        // UPDATE: Remove analyzingSwings case from switch
    }
}
```

### 1.3 Update ProcessingManager State Mapping
**File:** `Managers/ProcessingManager.swift`

```swift
private func mapProcessorState(_ state: VideoProcessor.ProcessingState) -> Session.ProcessingStatus {
    switch state {
    // ... existing cases ...
    // REMOVE: case .analyzingSwings
    case .complete:
        return .complete
    }
}
```

---

## Phase 2: Add On-Demand Analysis Storage (1 hour)

### 2.1 Extend Shot Model
**File:** `Models/Shot.swift`

```swift
struct Shot: Identifiable, Codable, Equatable {
    // ... existing fields ...
    
    // ADD new fields:
    var hasAIAnalysis: Bool = false
    var rawSwingData: Data? = nil  // Serialized ValidatedSwing for later use
}
```

### 2.2 Store Swing Data for Later Analysis
**File:** `Managers/AnalysisStore.swift`

```swift
// ADD method to update individual shot analysis:
static func updateShotAnalysis(videoFileName: String, shotID: UUID, strengths: [String], improvements: [String], score: Float) {
    guard var analysis = load(videoURL: URL(fileURLWithPath: videoFileName)) else { return }
    
    if let index = analysis.shots.firstIndex(where: { $0.id == shotID }) {
        analysis.shots[index].strengths = strengths
        analysis.shots[index].improvements = improvements
        analysis.shots[index].score = score
        analysis.shots[index].hasAIAnalysis = true
        
        // Re-save
        save(videoURL: URL(fileURLWithPath: videoFileName), 
             duration: analysis.duration, 
             shots: analysis.shots)
    }
}
```

### 2.3 Pass Swing Data Through Pipeline
**File:** `Core/VideoProcessor.swift`

```swift
// MODIFY to include swing data in AnalysisResult
let result = AnalysisResult(
    // ... existing fields ...
    swingType: swing.type,
    score: estimateBasicScore(metrics: segmentMetrics),
    strengths: [],
    improvements: [],
    keyFrames: [],
    validatedSwing: swing,  // ADD: Store for later
    segmentMetrics: segmentMetrics  // ADD: Store for later
)
```

**Note:** You'll need to make `ValidatedSwing` and `SegmentMetrics` Codable or store them differently.

---

## Phase 3: Create Analysis Service (1.5 hours)

### 3.1 Create New Analysis Service
**File:** `Managers/AIAnalysisService.swift` (NEW FILE)

```swift
import Foundation
import SwiftUI

@MainActor
class AIAnalysisService: ObservableObject {
    @Published var isAnalyzing = false
    @Published var currentAnalysisID: UUID?
    
    private let geminiValidator: GeminiValidator
    
    init() {
        self.geminiValidator = GeminiValidator(apiKey: Config.geminiAPIKey)
    }
    
    func analyzeShot(_ shot: Shot, videoFileName: String) async -> (strengths: [String], improvements: [String], score: Float)? {
        guard !shot.hasAIAnalysis else { 
            // Already analyzed, return existing
            return (shot.strengths, shot.improvements, shot.score)
        }
        
        isAnalyzing = true
        currentAnalysisID = shot.id
        defer { 
            isAnalyzing = false 
            currentAnalysisID = nil
        }
        
        // Reconstruct ValidatedSwing from stored data
        // This is a simplified version - you'll need to properly deserialize
        guard let swingData = shot.rawSwingData,
              let swing = try? JSONDecoder().decode(ValidatedSwing.self, from: swingData) else {
            return nil
        }
        
        // Calculate metrics from frames
        let metrics = MetricsCalculator().calculateSegmentMetrics(for: swing.frames)
        
        // Call Gemini for analysis
        do {
            let result = try await geminiValidator.analyzeSwing(swing, metrics: metrics)
            
            // Update storage
            AnalysisStore.updateShotAnalysis(
                videoFileName: videoFileName,
                shotID: shot.id,
                strengths: result.strengths,
                improvements: result.improvements,
                score: result.score
            )
            
            return (result.strengths, result.improvements, result.score)
        } catch {
            print("Analysis failed: \(error)")
            return nil
        }
    }
}
```

---

## Phase 4: Update AnalysisView UI (2.5 hours)

### 4.1 Modify AnalysisView Layout
**File:** `Views/AnalysisView.swift`

```swift
struct AnalysisView: View {
    let videoURL: URL?
    let duration: Double
    @State var shots: [Shot]  // Changed from let to @State for updates
    
    @StateObject private var aiService = AIAnalysisService()
    @State private var selectedShotID: Shot.ID?
    // ... other existing state ...
    
    var body: some View {
        VStack(spacing: 0) {
            // BIGGER Video Player (takes 50% of screen)
            if let url = videoURL {
                VideoPlayerView(url: url, currentTime: $currentTime, isPlaying: $isPlaying)
                    .frame(height: UIScreen.main.bounds.height * 0.45)
                    .clipShape(RoundedRectangle(cornerRadius: 20))
                    .padding(.horizontal, 12)
                    .padding(.top, 8)
            }
            
            // Timeline (stays as navigation)
            TimelineStripEnhanced(
                duration: duration,
                shots: shots,
                selectedShotID: $selectedShotID,
                currentTime: $currentTime,
                isPlaying: $isPlaying,
                onPlaySegment: { shot in playSegment(shot) }
            )
            .frame(height: 72)  // Slightly bigger
            .padding(.horizontal, 12)
            .padding(.vertical, 8)
            
            // Analysis Section
            ScrollView {
                if let selectedShot = shots.first(where: { $0.id == selectedShotID }) {
                    VStack(spacing: 16) {
                        // Shot Header
                        HStack {
                            VStack(alignment: .leading, spacing: 4) {
                                Text(selectedShot.type.accessibleName)
                                    .font(.title3.bold())
                                Text("Shot \(currentShotIndex + 1) of \(shots.count)")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            Spacer()
                            
                            // Basic score badge
                            Text(String(format: "%.1f", selectedShot.score))
                                .font(.system(size: 20, weight: .bold, design: .monospaced))
                                .foregroundColor(scoreColor(selectedShot.score))
                        }
                        .padding(.horizontal, 16)
                        
                        // AI Analysis Section
                        aiAnalysisSection(for: selectedShot)
                    }
                    .padding(.vertical, 12)
                }
            }
            .frame(maxHeight: .infinity)
        }
        .background(Color(UIColor.systemBackground))
    }
    
    // NEW: AI Analysis Section
    @ViewBuilder
    private func aiAnalysisSection(for shot: Shot) -> some View {
        let isAnalyzing = aiService.isAnalyzing && aiService.currentAnalysisID == shot.id
        
        Group {
            if shot.hasAIAnalysis {
                // Show existing analysis
                VStack(alignment: .leading, spacing: 12) {
                    if !shot.strengths.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                            Label("Strengths", systemImage: "checkmark.circle.fill")
                                .font(.caption.bold())
                                .foregroundColor(.green)
                            
                            ForEach(shot.strengths, id: \.self) { strength in
                                HStack(alignment: .top) {
                                    Circle().fill(Color.green).frame(width: 4, height: 4).offset(y: 6)
                                    Text(strength).font(.body)
                                }
                            }
                        }
                    }
                    
                    if !shot.improvements.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                            Label("Areas to Improve", systemImage: "arrow.triangle.2.circlepath")
                                .font(.caption.bold())
                                .foregroundColor(.orange)
                            
                            ForEach(shot.improvements, id: \.self) { improvement in
                                HStack(alignment: .top) {
                                    Circle().fill(Color.orange).frame(width: 4, height: 4).offset(y: 6)
                                    Text(improvement).font(.body)
                                }
                            }
                        }
                    }
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 16)
                        .fill(Color(UIColor.secondarySystemBackground))
                )
                .padding(.horizontal, 16)
                
            } else if isAnalyzing {
                // Loading state
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Analyzing your swing...")
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 16)
                        .fill(Color(UIColor.secondarySystemBackground))
                )
                .padding(.horizontal, 16)
                
            } else {
                // CTA Button
                Button(action: { Task { await generateAnalysis(for: shot) } }) {
                    HStack(spacing: 12) {
                        Image(systemName: "wand.and.stars")
                            .font(.title3)
                        
                        VStack(alignment: .leading, spacing: 2) {
                            Text("Get AI Coaching")
                                .font(.headline)
                            Text("Personalized feedback for this shot")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        Spacer()
                        
                        Image(systemName: "chevron.right.circle.fill")
                            .font(.title2)
                            .foregroundColor(TennisColors.tennisYellow)
                    }
                    .foregroundColor(.primary)
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .fill(TennisColors.tennisGreen.opacity(0.15))
                            .overlay(
                                RoundedRectangle(cornerRadius: 16)
                                    .stroke(TennisColors.tennisGreen, lineWidth: 2)
                            )
                    )
                }
                .padding(.horizontal, 16)
            }
        }
    }
    
    // NEW: Generate Analysis
    private func generateAnalysis(for shot: Shot) async {
        guard let videoFileName = videoURL?.lastPathComponent else { return }
        
        if let result = await aiService.analyzeShot(shot, videoFileName: videoFileName) {
            // Update the shot in our local state
            if let index = shots.firstIndex(where: { $0.id == shot.id }) {
                shots[index].strengths = result.strengths
                shots[index].improvements = result.improvements
                shots[index].score = result.score
                shots[index].hasAIAnalysis = true
            }
        }
    }
}
```

---

## Phase 5: Testing & Polish (1 hour)

### 5.1 Test Checklist
- [ ] Upload video → Processing completes faster (no AI delay)
- [ ] Navigate to AnalysisView → Video plays, timeline works
- [ ] Tap "Get AI Coaching" → Loading state appears
- [ ] AI analysis completes → Results display correctly
- [ ] Switch shots → Previous analysis persists
- [ ] Close and reopen app → Analysis results are saved

### 5.2 Edge Cases to Handle
- Network failure during AI analysis
- User navigates away during analysis
- Multiple rapid analysis requests
- Very short or invalid swings

### 5.3 Performance Optimizations
- Cache `ValidatedSwing` data efficiently
- Consider compression for stored swing data
- Implement request debouncing for analysis button

---

## Migration Notes

### Breaking Changes
- `AnalysisResult` no longer contains AI feedback by default
- Processing completes faster (users might notice)
- `Shot` model has new fields

### Data Migration
- Existing sessions will show "Get AI Coaching" for all shots
- Old analysis data remains but may need manual migration

### Rollback Plan
- Keep old `VideoProcessor` code commented for 1 release
- Can revert by uncommenting analysis loop
- Store version flag in `UserDefaults` for A/B testing

---

## Success Metrics

| Metric | Current | Target | Measurement |
|--------|---------|--------|-------------|
| Processing Time | 45-60s | 20-30s | Timer in VideoProcessor |
| API Calls per Session | 8-10 | 2-3 | Gemini API logs |
| User Engagement | N/A | 80% tap CTA | Analytics event |
| Cost per User | $0.15 | $0.05 | API billing |
